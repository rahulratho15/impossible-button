<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Impossible Button</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body {
            font-family: 'VT323', monospace;
            background: #000;
            color: #00ff00;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 0, 0.03),
                rgba(0, 255, 0, 0.03) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1000;
        }

        @keyframes glitch {
            0% { text-shadow: 2px 2px #ff00ff, -2px -2px #00ffff; }
            25% { text-shadow: -2px 2px #ff00ff, 2px -2px #00ffff; }
            50% { text-shadow: 2px -2px #ff00ff, -2px 2px #00ffff; }
            75% { text-shadow: -2px -2px #ff00ff, 2px 2px #00ffff; }
            100% { text-shadow: 2px 2px #ff00ff, -2px -2px #00ffff; }
        }

        .glitch {
            animation: glitch 0.3s infinite;
        }

        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-10px, 10px); }
            20%, 40%, 60%, 80% { transform: translate(10px, -10px); }
        }

        .shake {
            animation: shake 0.5s;
        }

        @keyframes flashGreen {
            0%, 100% { background: #000; }
            50% { background: #003300; }
        }

        @keyframes flashRed {
            0%, 100% { background: #000; }
            50% { background: #330000; }
        }

        .flash-green {
            animation: flashGreen 0.3s 2;
        }

        .flash-red {
            animation: flashRed 0.3s 2;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            padding: 20px;
            z-index: 1;
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            font-size: 28px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ff00;
        }

        #level-indicator {
            font-weight: bold;
            color: #00ff00;
        }

        #progress-bar {
            width: 100%;
            height: 10px;
            background: #003300;
            border: 2px solid #00ff00;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00ff88);
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 10px #00ff00;
        }

        #instruction {
            font-size: 48px;
            text-align: center;
            margin: 30px 0;
            min-height: 60px;
            text-shadow: 0 0 20px #00ff00;
        }

        #visual-area {
            font-size: 80px;
            text-align: center;
            min-height: 100px;
            margin: 20px 0;
        }

        #button-area {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 0 auto;
        }

        #timer-ring {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        #the-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: #003300;
            border: 5px solid #00ff00;
            box-shadow: 0 0 30px #00ff00, inset 0 0 30px rgba(0, 255, 0, 0.3);
            cursor: pointer;
            font-size: 32px;
            color: #00ff00;
            transition: all 0.1s;
            touch-action: manipulation;
        }

        #the-button:active {
            transform: translate(-50%, -50%) scale(0.95);
            box-shadow: 0 0 50px #00ff00, inset 0 0 50px rgba(0, 255, 0, 0.5);
        }

        #click-counter {
            text-align: center;
            font-size: 24px;
            margin-top: 30px;
            text-shadow: 0 0 10px #00ff00;
        }

        #menu, #game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #menu h1, #game-over h1 {
            font-size: 64px;
            margin-bottom: 30px;
            text-shadow: 0 0 30px #00ff00;
        }

        #menu p {
            font-size: 32px;
            margin-bottom: 50px;
        }

        .menu-button {
            padding: 20px 60px;
            font-size: 36px;
            background: #003300;
            border: 3px solid #00ff00;
            color: #00ff00;
            cursor: pointer;
            font-family: 'VT323', monospace;
            box-shadow: 0 0 20px #00ff00;
            transition: all 0.2s;
        }

        .menu-button:hover {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 40px #00ff00;
        }

        .hidden {
            display: none !important;
        }

        #final-score {
            font-size: 48px;
            margin: 20px 0;
            text-shadow: 0 0 20px #00ff00;
        }

        @media (max-width: 600px) {
            #instruction { font-size: 36px; }
            #visual-area { font-size: 60px; }
            #button-area { width: 250px; height: 250px; }
            #the-button { width: 170px; height: 170px; }
        }
    </style>
</head>
<body>
    <div id="menu">
        <h1 class="glitch">THE IMPOSSIBLE BUTTON</h1>
        <p>CAN YOU SURVIVE?</p>
        <button class="menu-button" id="start-btn">READY?</button>
    </div>

    <div id="game-over" class="hidden">
        <h1>GAME OVER</h1>
        <div id="final-score">LEVEL: 0</div>
        <button class="menu-button" id="retry-btn">RETRY</button>
    </div>

    <div id="game-container" class="hidden">
        <div id="top-bar">
            <div id="level-indicator">LEVEL: <span id="level">1</span>/10</div>
            <div>SCORE: <span id="score">0</span></div>
        </div>

        <div id="progress-bar">
            <div id="progress-fill"></div>
        </div>

        <div id="instruction" class="glitch"></div>
        <div id="visual-area"></div>

        <div id="button-area">
            <svg id="timer-ring" viewBox="0 0 100 100">
                <circle cx="50" cy="50" r="45" fill="none" stroke="#003300" stroke-width="3"/>
                <circle id="timer-circle" cx="50" cy="50" r="45" fill="none" stroke="#00ff00" 
                        stroke-width="3" stroke-dasharray="283" stroke-dashoffset="0"
                        style="filter: drop-shadow(0 0 5px #00ff00);"/>
            </svg>
            <button id="the-button">PRESS</button>
        </div>

        <div id="click-counter">CLICKS: <span id="clicks">0</span></div>
    </div>

    <script>
        // Audio System
        const AudioSystem = {
            ctx: null,
            init() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            },
            beep(freq = 400, duration = 0.1) {
                if (!this.ctx) this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            success() {
                this.beep(600, 0.1);
                setTimeout(() => this.beep(800, 0.15), 100);
            },
            fail() {
                this.beep(200, 0.3);
                setTimeout(() => this.beep(150, 0.4), 150);
            }
        };

        // Game State
        const Game = {
            level: 1,
            score: 0,
            clicks: 0,
            timeLeft: 3000,
            timerInterval: null,
            currentTask: null,
            isHolding: false,
            holdStartTime: null,
            gameActive: false,
            roundsInLevel: 0,
            failuresInRow: 0,
            taskDeck: [],
            coyoteTimeBuffer: 50,

            // Level configurations (1-10)
            levelConfig: [
                { baseTime: 2000, tasks: ['press', 'dontpress'], spamCount: 5, mathMax: 5, exactSpam: false },
                { baseTime: 1900, tasks: ['press', 'dontpress', 'math'], spamCount: 6, mathMax: 6, exactSpam: false },
                { baseTime: 1800, tasks: ['press', 'dontpress', 'math', 'spam'], spamCount: 8, mathMax: 8, exactSpam: false },
                { baseTime: 1700, tasks: ['press', 'dontpress', 'math', 'spam'], spamCount: 10, mathMax: 10, exactSpam: true },
                { baseTime: 1600, tasks: ['press', 'dontpress', 'math', 'spam', 'hold'], spamCount: 12, mathMax: 12, exactSpam: true },
                { baseTime: 1500, tasks: ['press', 'dontpress', 'math', 'spam', 'hold', 'rat'], spamCount: 15, mathMax: 15, exactSpam: true },
                { baseTime: 1400, tasks: ['press', 'dontpress', 'math', 'spam', 'hold', 'rat'], spamCount: 18, mathMax: 18, exactSpam: true },
                { baseTime: 1300, tasks: ['press', 'dontpress', 'math', 'spam', 'hold', 'rat'], spamCount: 20, mathMax: 20, exactSpam: true },
                { baseTime: 1200, tasks: ['press', 'dontpress', 'math', 'spam', 'hold', 'rat'], spamCount: 25, mathMax: 25, exactSpam: true },
                { baseTime: 1100, tasks: ['press', 'dontpress', 'math', 'spam', 'hold', 'rat'], spamCount: 30, mathMax: 30, exactSpam: true }
            ],

            taskDefinitions: {
                press: { 
                    text: 'PRESS', 
                    complexity: 500,
                    check: (g) => g.clicks === 1 
                },
                dontpress: { 
                    text: 'DO NOT PRESS', 
                    complexity: 1500,
                    check: (g) => g.clicks === 0 
                },
                math: { 
                    text: '', 
                    complexity: 800,
                    check: (g) => g.clicks === g.currentTask.target 
                },
                spam: { 
                    text: '', 
                    complexity: 0,
                    check: (g) => {
                        const config = g.levelConfig[Math.min(g.level - 1, 9)];
                        if (config.exactSpam) {
                            return g.clicks === g.currentTask.target;
                        }
                        return g.clicks >= g.currentTask.target;
                    }
                },
                hold: { 
                    text: 'HOLD', 
                    complexity: 1800,
                    check: (g) => g.isHolding && g.holdStartTime !== null 
                },
                rat: { 
                    text: 'PRESS IF RAT', 
                    complexity: 1200,
                    check: (g) => {
                        if (g.currentTask.isRat) return g.clicks === 1;
                        return g.clicks === 0;
                    }
                }
            },

            init() {
                this.level = 1;
                this.score = 0;
                this.roundsInLevel = 0;
                this.failuresInRow = 0;
                this.refillTaskDeck();
                this.updateUI();
            },

            refillTaskDeck() {
                const config = this.levelConfig[Math.min(this.level - 1, 9)];
                this.taskDeck = [];
                
                // Create balanced deck: 2 of each task type
                config.tasks.forEach(task => {
                    this.taskDeck.push(task, task);
                });
                
                // Shuffle using Fisher-Yates
                for (let i = this.taskDeck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.taskDeck[i], this.taskDeck[j]] = [this.taskDeck[j], this.taskDeck[i]];
                }
            },

            drawTask() {
                if (this.taskDeck.length === 0) {
                    this.refillTaskDeck();
                }
                return this.taskDeck.pop();
            },

            startLevel() {
                this.clicks = 0;
                this.isHolding = false;
                this.holdStartTime = null;
                this.gameActive = true;
                this.roundsInLevel++;
                document.getElementById('clicks').textContent = '0';
                
                const config = this.levelConfig[Math.min(this.level - 1, 9)];
                
                // Draw task from deck
                const taskType = this.drawTask();
                const taskTemplate = this.taskDefinitions[taskType];
                
                this.currentTask = { type: taskType, ...taskTemplate };

                // Setup task-specific logic
                if (this.currentTask.type === 'math') {
                    const a = Math.floor(Math.random() * config.mathMax) + 1;
                    const b = Math.floor(Math.random() * config.mathMax) + 1;
                    const op = Math.random() > 0.5 ? '+' : '-';
                    this.currentTask.target = op === '+' ? a + b : Math.max(a - b, 0);
                    this.currentTask.text = `${a} ${op} ${b}`;
                    document.getElementById('visual-area').textContent = '';
                } else if (this.currentTask.type === 'spam') {
                    this.currentTask.target = config.spamCount;
                    const exactText = config.exactSpam ? ' EXACTLY' : '';
                    this.currentTask.text = `PRESS${exactText} ${config.spamCount} TIMES`;
                    this.currentTask.complexity = config.spamCount * 100;
                    document.getElementById('visual-area').textContent = '';
                } else if (this.currentTask.type === 'rat') {
                    this.currentTask.isRat = Math.random() > 0.5;
                    document.getElementById('visual-area').textContent = this.currentTask.isRat ? 'ðŸ€' : 'ðŸ•·ï¸';
                } else {
                    document.getElementById('visual-area').textContent = '';
                }

                document.getElementById('instruction').textContent = this.currentTask.text;
                
                // Adaptive timer calculation
                let adaptiveTime = config.baseTime + this.currentTask.complexity;
                
                // Dynamic Difficulty Adjustment
                if (this.failuresInRow >= 3) {
                    adaptiveTime *= 1.3;
                }
                
                this.timeLeft = adaptiveTime;
                this.startTimer();
                AudioSystem.beep(500, 0.05);
            },

            startTimer() {
                const circle = document.getElementById('timer-circle');
                const circumference = 283;
                const startTime = Date.now();
                const duration = this.timeLeft;

                this.timerInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const remaining = Math.max(0, duration - elapsed);
                    const progress = remaining / duration;
                    circle.style.strokeDashoffset = circumference * (1 - progress);

                    if (remaining <= 0) {
                        this.endLevel();
                    }
                }, 16);
            },

            endLevel(immediate = false) {
                if (!this.gameActive) return;
                
                clearInterval(this.timerInterval);
                this.gameActive = false;

                const success = this.currentTask.check(this);
                
                if (success) {
                    this.win();
                } else {
                    // Coyote time: give 50ms grace period for late clicks
                    if (!immediate) {
                        setTimeout(() => {
                            if (!this.gameActive) {
                                this.lose();
                            }
                        }, this.coyoteTimeBuffer);
                    } else {
                        this.lose();
                    }
                }
            },

            win() {
                AudioSystem.success();
                document.body.classList.add('flash-green');
                
                this.failuresInRow = 0;
                
                const pointsEarned = this.level * 10;
                this.score += pointsEarned;
                
                const previousLevel = this.level;
                this.level = Math.min(Math.floor(this.score / 100) + 1, 10);
                
                const leveledUp = this.level > previousLevel;
                
                this.updateUI();

                setTimeout(() => {
                    document.body.classList.remove('flash-green');
                    
                    if (leveledUp) {
                        this.showLevelUp();
                    } else {
                        this.startLevel();
                    }
                }, 600);
            },

            showLevelUp() {
                const instruction = document.getElementById('instruction');
                instruction.textContent = `ðŸŽ‰ LEVEL ${this.level} UNLOCKED! ðŸŽ‰`;
                instruction.style.fontSize = '42px';
                AudioSystem.beep(800, 0.2);
                setTimeout(() => AudioSystem.beep(1000, 0.2), 200);
                
                setTimeout(() => {
                    instruction.style.fontSize = '48px';
                    this.roundsInLevel = 0;
                    this.refillTaskDeck();
                    this.startLevel();
                }, 2000);
            },

            lose() {
                AudioSystem.fail();
                document.body.classList.add('flash-red', 'shake');
                this.failuresInRow++;
                
                setTimeout(() => {
                    document.body.classList.remove('flash-red', 'shake');
                    this.gameOver();
                }, 600);
            },

            gameOver() {
                document.getElementById('game-container').classList.add('hidden');
                document.getElementById('final-score').textContent = `LEVEL: ${this.level} | SCORE: ${this.score}`;
                document.getElementById('game-over').classList.remove('hidden');
            },

            updateUI() {
                document.getElementById('level').textContent = this.level;
                document.getElementById('score').textContent = this.score;
                
                const progressInLevel = this.score % 100;
                document.getElementById('progress-fill').style.width = progressInLevel + '%';
            },

            handleClick() {
                if (!this.gameActive) return;
                
                this.clicks++;
                document.getElementById('clicks').textContent = this.clicks;
                AudioSystem.beep(600, 0.05);

                // Instant win/lose checks for certain tasks
                if (this.currentTask.type === 'press' && this.clicks === 1) {
                    clearInterval(this.timerInterval);
                    this.endLevel();
                }
                
                if (this.currentTask.type === 'dontpress' && this.clicks > 0) {
                    clearInterval(this.timerInterval);
                    this.endLevel(true);
                }

                // Check if spam/math task completed
                if (this.currentTask.type === 'spam' || this.currentTask.type === 'math') {
                    const config = this.levelConfig[Math.min(this.level - 1, 9)];
                    
                    // Exact spam mode: fail if over target
                    if (this.currentTask.type === 'spam' && config.exactSpam && this.clicks > this.currentTask.target) {
                        clearInterval(this.timerInterval);
                        this.endLevel(true);
                    }
                    
                    // Success condition met
                    if (this.clicks === this.currentTask.target) {
                        clearInterval(this.timerInterval);
                        this.endLevel();
                    }
                }

                // Rat task instant check
                if (this.currentTask.type === 'rat') {
                    if (this.clicks === 1) {
                        clearInterval(this.timerInterval);
                        this.endLevel();
                    } else if (this.clicks > 1) {
                        clearInterval(this.timerInterval);
                        this.endLevel(true);
                    }
                }
            },

            handlePointerDown() {
                if (!this.gameActive) return;
                
                if (this.currentTask.type === 'hold' && !this.isHolding) {
                    this.isHolding = true;
                    this.holdStartTime = Date.now();
                }
            },

            handlePointerUp() {
                if (!this.gameActive) return;
                
                if (this.currentTask.type === 'hold' && this.isHolding) {
                    const holdDuration = Date.now() - this.holdStartTime;
                    const requiredDuration = this.timeLeft - 200;
                    
                    // If released too early, instant fail
                    if (holdDuration < requiredDuration) {
                        this.isHolding = false;
                        clearInterval(this.timerInterval);
                        this.endLevel(true);
                    }
                }
            }
        };

        // Event Listeners
        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('menu').classList.add('hidden');
            document.getElementById('game-container').classList.remove('hidden');
            Game.init();
            Game.startLevel();
        });

        document.getElementById('retry-btn').addEventListener('click', () => {
            document.getElementById('game-over').classList.add('hidden');
            document.getElementById('game-container').classList.remove('hidden');
            Game.init();
            Game.startLevel();
        });

        const button = document.getElementById('the-button');
        
        button.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            Game.handlePointerDown();
            Game.handleClick();
        });

        button.addEventListener('pointerup', (e) => {
            e.preventDefault();
            Game.handlePointerUp();
        });

        button.addEventListener('contextmenu', (e) => e.preventDefault());
    </script>
</body>
</html>